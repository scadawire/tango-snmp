/*----- PROTECTED REGION ID(TangoSnmp.cpp) ENABLED START -----*/
static const char *RcsId = "$Id$";
//=============================================================================
//
// file :        TangoSnmp.cpp
//
// description : C++ source for the TangoSnmp class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               TangoSnmp are implemented in this file.
//
// project :     Tango<-->Snmp link
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author$
//
// $Revision$
// $Date$
//
// $HeadURL$
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <TangoSnmp.h>
#include <TangoSnmpClass.h>

#include <TangoSnmp.tpp>

/*----- PROTECTED REGION END -----*/	//	TangoSnmp.cpp

/**
 *  TangoSnmp class description:
 *    This class is  a bridge between Tango and SNMP. It allows the user to get/set
 *    snmp data to/from a snmp agent. It is built on top of the <a href="http://www.net-snmp.org" target="_top">net-snmp</a> library.
 *    You can get/set SNMP data using generic commands or you can configure
 *    this Tango class to create  dynamic attributes which are the Tango part of SNMP data.
 *    See the definition of the device properties to find out how this can be achieved.
 *    To communicate with the SNMP agent, this class uses SNMP v2c.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  GetSnmpData   |  get_snmp_data
//  SetSnmpData   |  set_snmp_data
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  MIBFileDirs       |  Tango::DevString	Spectrum  ( max = 128)
//  LoadedMIBModules  |  Tango::DevString	Spectrum  ( max = 1024)
//================================================================

namespace TangoSnmp_ns
{
/*----- PROTECTED REGION ID(TangoSnmp::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::TangoSnmp()
 *	Description : Constructors for a Tango device
 *                implementing the classTangoSnmp
 */
//--------------------------------------------------------
TangoSnmp::TangoSnmp(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(TangoSnmp::constructor_1) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::constructor_1
}
//--------------------------------------------------------
TangoSnmp::TangoSnmp(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(TangoSnmp::constructor_2) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::constructor_2
}
//--------------------------------------------------------
TangoSnmp::TangoSnmp(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(TangoSnmp::constructor_3) ENABLED START -----*/
	init_device();

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void TangoSnmp::delete_device()
{
	DEBUG_STREAM << "TangoSnmp::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::delete_device) ENABLED START -----*/

	//	Delete device allocated objects

    if (ss != NULL) 
    {
        snmp_sess_close(ss);
    }
	Tango::Util *tg = Tango::Util::instance();
	if (tg->is_device_restarting(get_name()) == false)
	{
		TangoSnmpClass *cl_ptr = static_cast<TangoSnmpClass *>(get_device_class());
		Tango::DevVarStringArray dvsa;
		dvsa.length(1);
		dvsa[0] = Tango::string_dup(get_name().c_str());
		cl_ptr->erase_dynamic_attributes(&dvsa, cl_ptr->get_class_attr()->get_attr_list());
	}

	map<string,BaseSnmpData *>::iterator data_ite;
	for (data_ite = dattr_scalar_data.begin();data_ite != dattr_scalar_data.end();++data_ite)
		delete data_ite->second;

	for (data_ite = dattr_spectrum_data.begin();data_ite != dattr_spectrum_data.end();++data_ite)
		delete data_ite->second;

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void TangoSnmp::init_device()
{
	DEBUG_STREAM << "TangoSnmp::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(TangoSnmp::init_device) ENABLED START -----*/

	set_state(Tango::ON);
	device_status = Tango::StatusNotSet;

//
// Init net-snmp lib
//

	init_snmp("TangoSnmpDs");
	init_mib();

//
// Init session using SNMP V2c
//

	snmp_sess_init(&session);

    if (!simulationMode) {
		session.peername = const_cast<char *>(agentIpAddr.c_str());
    } else {
        //have to make my own session


        // AB commented this part out after POGO run removed the variable 
        // dummyIpAddr = "dummy";
        // session.peername = const_cast<char *>(dummyIpAddr.c_str());
    }
	session.version = SNMP_VERSION_2c;
	session.community = (u_char*)strdup(community.c_str());
	session.community_len = strlen((char*)session.community);
	session.timeout = timeout;
	session.retries = 0;

//
// Open the session
//
    if (simulationMode) 
    {
        //_init_snmp();
    } else 
    {
		ss = snmp_sess_open(&session);
		if (!ss)
		{
			set_state(Tango::FAULT);
			char *tmp_err_mess = NULL;
			snmp_sess_perror(tmp_err_mess,&session);

			set_status("Can't connect to SNMP agent on address ");
			append_status(agentIpAddr.c_str());
			append_status("SNMP lib error message: ",true);
//			append_status(tmp_err_mess); */
		}
	}

//
// Add dynamic attributes if needed
//

	Tango::Util *tg = Tango::Util::instance();
	if (tg->is_svr_starting() == false && tg->is_device_restarting(get_name()) == false)
	{
		add_dynamic_attributes();
	}

//
// If the MIB files property is defined, check that pathes are absolute pathes
//

	if (mIBFile.empty() == false)
	{
		for (size_t loop = 0;loop < mIBFile.size();loop++)
		{
			if (mIBFile[loop][0] != '/')
			{
				bool already_alarm = false;

				if (get_state() == Tango::ALARM)
					already_alarm = true;
				else
					set_state(Tango::ALARM);

				stringstream ss;
				ss << "MIB File " << mIBFile[loop] << " is not defined with an absolute path name";

				if (already_alarm == true)
					append_status(ss.str(),true);
				else
					set_status(ss.str());
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::init_device
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void TangoSnmp::get_device_property()
{
	/*----- PROTECTED REGION ID(TangoSnmp::get_device_property_before) ENABLED START -----*/

	//	Initialize property data members

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("community"));
	dev_prop.push_back(Tango::DbDatum("timeout"));
	dev_prop.push_back(Tango::DbDatum("MIBFile"));
	dev_prop.push_back(Tango::DbDatum("AgentIpAddr"));
	dev_prop.push_back(Tango::DbDatum("DynamicAttributes"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on TangoSnmpClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		TangoSnmpClass	*ds_class =
			(static_cast<TangoSnmpClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize community from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  community;
		else {
			//	Try to initialize community from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  community;
		}
		//	And try to extract community value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  community;

		//	Try to initialize timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
		else {
			//	Try to initialize timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  timeout;
		}
		//	And try to extract timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;

		//	Try to initialize MIBFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mIBFile;
		else {
			//	Try to initialize MIBFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mIBFile;
		}
		//	And try to extract MIBFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mIBFile;

		//	Try to initialize AgentIpAddr from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  agentIpAddr;
		else {
			//	Try to initialize AgentIpAddr from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  agentIpAddr;
		}
		//	And try to extract AgentIpAddr value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  agentIpAddr;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize DynamicAttributes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynamicAttributes;
		else {
			//	Try to initialize DynamicAttributes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynamicAttributes;
		}
		//	And try to extract DynamicAttributes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynamicAttributes;

	}

	/*----- PROTECTED REGION ID(TangoSnmp::get_device_property_after) ENABLED START -----*/

	//	Check device property data members init

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void TangoSnmp::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(TangoSnmp::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;

		/*----- PROTECTED REGION END -----*/	//	TangoSnmp::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void TangoSnmp::always_executed_hook()
{
	DEBUG_STREAM << "TangoSnmp::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"TangoSnmp::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(TangoSnmp::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void TangoSnmp::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "TangoSnmp::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::read_attr_hardware) ENABLED START -----*/

	//	Add your own code

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute MIBFileDirs related method
 *	Description: This attribute is the list of directories where the sofwtare will look for MIB files.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 128
 */
//--------------------------------------------------------
void TangoSnmp::read_MIBFileDirs(Tango::Attribute &attr)
{
	DEBUG_STREAM << "TangoSnmp::read_MIBFileDirs(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::read_MIBFileDirs) ENABLED START -----*/
	//	Set the attribute value

//
// Get directory paths from net-snmp
//

	char *path = netsnmp_get_mib_directory();

	if (path == NULL)
	{
		Tango::Except::throw_exception("TangoSnmp_CantGetMibDirs",
									   "The Net-SNMP call to retrieve MIB dirs failed",
									   "TangoSnmp::read_MIBFileDirs");
	}

//
// Split info returned by net-snmp (: is used by net-snmp as directory separator)
//

	attr_MIBFileDirs_read = new Tango::DevString[64];

	string dirs(path);
	string::size_type pos = 0;
	string::size_type start = 0;

	int dir_cptr = 0;

	while(true)
	{
		if (dir_cptr == 64)
		{
			for (int i = 0;i < dir_cptr;i++)
				CORBA::string_free(attr_MIBFileDirs_read[dir_cptr]);
			delete [] attr_MIBFileDirs_read;
			Tango::Except::throw_exception("TangoSnmp_TooManyDirs",
									   "Too many dirs (> 64) in the path returned by net-snmp",
									   "TangoSnmp::read_MIBFileDirs");
		}

		pos = dirs.find(':',pos);
		if (pos == string::npos)
		{
			string dir = dirs.substr(start);
			attr_MIBFileDirs_read[dir_cptr] = Tango::string_dup(dir.c_str());
			dir_cptr++;
			break;
		}
		string dir = dirs.substr(start,pos - start);
		attr_MIBFileDirs_read[dir_cptr] = Tango::string_dup(dir.c_str());
		dir_cptr++;
		pos++;
		start = pos;
	}

	attr.set_value(attr_MIBFileDirs_read,dir_cptr,0,true);

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::read_MIBFileDirs
}
//--------------------------------------------------------
/**
 *	Read attribute LoadedMIBModules related method
 *	Description: This is the list of the MIB modules loaded in the Tango server
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1024
 */
//--------------------------------------------------------
void TangoSnmp::read_LoadedMIBModules(Tango::Attribute &attr)
{
	DEBUG_STREAM << "TangoSnmp::read_LoadedMIBModules(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::read_LoadedMIBModules) ENABLED START -----*/
	//	Set the attribute value

	attr_LoadedMIBModules_read = new Tango::DevString[1024];
	vector<string> v_str;

//
// Get the module list
//

	int cptr;
	for (cptr = 0;cptr < 1024;cptr++)
	{
		struct module *mod = find_module(cptr);
		if (mod == NULL)
			break;
		else
		{
			stringstream ss;
			ss << "Module " << mod->name << " from file " << mod->file;
			v_str.emplace_back(ss.str());
		}
	}

//
// Alphabetically sort the vector
//

	sort(v_str.begin(),v_str.end());

//
// Init data to be returned
//

	for (int i = 0;i < cptr;i++)
	{
		attr_LoadedMIBModules_read[i] = Tango::string_dup(v_str[i] .c_str());
	}

	attr.set_value(attr_LoadedMIBModules_read, cptr,0,true);

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::read_LoadedMIBModules
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void TangoSnmp::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(TangoSnmp::add_dynamic_attributes) ENABLED START -----*/

	//	Add your own code to create and add dynamic attributes if any

//
// If the property is defined, check its validity and parse it
// Get the attribute name, data_type, RW type, label, unit and format
//

	if (dynamicAttributes.empty() == false)
	{
		bool first_coherency_failed = true;

		for (size_t loop = 0;loop < dynamicAttributes.size();loop++)
		{
			string::size_type pos_equal = dynamicAttributes[loop].find('=');
			string::size_type pos_comma = dynamicAttributes[loop].find(',');
			if (pos_equal == string::npos || pos_comma == string::npos || pos_comma < pos_equal)
			{
				set_state(Tango::ALARM);

				stringstream ss;
				ss << "Definition: \"" << dynamicAttributes[loop] << "\" for a dynamic attribute is not correct (missing = or ,)";
				set_status(ss.str());
				continue;
			}

			string att_name = dynamicAttributes[loop].substr(0,pos_equal);

			string snmp_name,att_data_type,att_rw,att_label,att_unit,att_format;
			int cptr = 0;
			string::size_type start = 0;
			pos_equal++;

			while (true)
			{
				if (cptr != 0)
					pos_comma = dynamicAttributes[loop].find(',',pos_comma);

				if (pos_comma == string::npos)
				{
					switch(cptr)
					{
					case 1:
						att_data_type = dynamicAttributes[loop].substr(start);
						break;

					case 2:
						att_rw = dynamicAttributes[loop].substr(start);
						break;

					case 3:
						att_label = dynamicAttributes[loop].substr(start);
						break;

					case 4:
						att_unit = dynamicAttributes[loop].substr(start);
						break;

					case 5:
						att_format = dynamicAttributes[loop].substr(start);
						break;

					default:
						break;
					}
					break;
				}

				switch (cptr)
				{
				case 0:
					snmp_name = dynamicAttributes[loop].substr(pos_equal,pos_comma - pos_equal);
					break;

				case 1:
					att_data_type = dynamicAttributes[loop].substr(start,pos_comma - start);
					break;

				case 2:
					att_rw = dynamicAttributes[loop].substr(start,pos_comma - start);
					break;

				case 3:
					att_label = dynamicAttributes[loop].substr(start,pos_comma - start);
					break;

				case 4:
					att_unit = dynamicAttributes[loop].substr(start,pos_comma - start);
					break;

				default:
					break;
				}

				cptr++;
				pos_comma++;
				start = pos_comma;
			}

			DEBUG_STREAM << "att name = " << att_name << ", snmp name = " << snmp_name << ", data type = " << att_data_type << ", rw = " << att_rw << ", label = " << att_label << ", att_unit = " << att_unit << ", format = " << att_format << endl;

//
// Check user attribute RW type value
// The default value for attribute RW type is READ
//

			Tango::AttrWriteType att_w_type;

			if (att_rw.empty() == true)
			{
				att_w_type = Tango::READ;
			}
			else
			{
				transform(att_rw.begin(),att_rw.end(),att_rw.begin(),::tolower);
				if (att_rw == "read")
					att_w_type = Tango::READ;
				else if (att_rw == "read_write")
					att_w_type = Tango::READ_WRITE;
				else
				{
					set_state(Tango::ALARM);

					stringstream ss;
					ss << "Attribute " << att_name << " has an undefined Tango RW type (" << att_rw << ")";
					set_status(ss.str());

					continue;
				}
			}

//
// Check user attribute data type validity
//

			long data_type;

			transform(att_data_type.begin(),att_data_type.end(),att_data_type.begin(),::tolower);

			if (att_data_type == "devstring")
				data_type = Tango::DEV_STRING;
			else if (att_data_type == "devlong")
				data_type = Tango::DEV_LONG;
			else if (att_data_type == "devulong")
				data_type = Tango::DEV_ULONG;
			else if (att_data_type == "devulong64")
				data_type = Tango::DEV_ULONG64;
			else
			{
				set_state(Tango::ALARM);

				stringstream ss;
				ss << "Attribute " << att_name << " has an undefined Tango data type (" << att_data_type << ")";
				set_status(ss.str());

				continue;
			}

//
// Check attribute definition coherency with info retrieved from SNMP
//

			bool create_attribute = false;
			bool spectrum = false;
			string required_type;

			int res = check_coherency(snmp_name,att_data_type,att_w_type,att_name,required_type);
			if (res != 0)
			{
				if (res == -4)
				{

//
// There are some cases where the data is defined in the MIB but is not accessible in SNMP as is
// For instance, it is the case of all scalar data which should be accessed with one extra .0 at the end
// of the SNMP name (sysDescr.0 instead of simply sysDescr).
//

					string snmp_name_scalar = snmp_name + ".0";
					res = check_coherency(snmp_name_scalar,att_data_type,att_w_type,att_name,required_type);
					if (res == -1)
					{

//
// The data is defined in the MIB and in the agent but not as a scalar (.0), try to get it as one array
//

						res = read_snmp_data_bulk_coherency(att_name,snmp_name);
						if (res != 0)
						{
							set_state(Tango::ALARM);

							stringstream ss;
							ss << "Can't read data from SNMP for attribute " << att_name;

							if (first_coherency_failed == true)
							{
								set_status(ss.str());
								first_coherency_failed = false;
							}
							else
								append_status(ss.str(),true);
						}
						else
						{
							create_attribute = true;
							spectrum = true;
						}
					}
					else if (res == -4)
					{
						set_state(Tango::ALARM);

						stringstream ss;
						ss << "Can't find data " << snmp_name << " in SNMP for attribute " << att_name;

						if (first_coherency_failed == true)
						{
							set_status(ss.str());
							first_coherency_failed = false;
						}
						else
							append_status(ss.str(),true);
					}
					else
						create_attribute = true;
				}
				else
				{
					set_state(Tango::ALARM);

					stringstream ss;
					if (res == -1)
						ss << "Snmp data " << snmp_name << " cannot be found in loaded MIB";
					else if (res == -2)
					{
						ss << "Attribute " << att_name << " definition is not coherent with SNMP definition";
						ss << "\nRead-Write type differs!";
					}
					else if (res == -3)
					{
						ss << "Attribute " << att_name << " definition is not coherent with SNMP definition";
						ss << "\nData type incompatible! Should be " << required_type;
					}
					else if (res == -5)
					{
						ss << "Attribute " << att_name << " with snmp data " << snmp_name << " cannot be found";
					}

					if (first_coherency_failed == true)
					{
						set_status(ss.str());
						first_coherency_failed = false;
					}
					else
						append_status(ss.str(),true);
				}
			}
			else
			{
				create_attribute = true;
			}

//
// Create the dynamic attribute
//
// If the user want the attribute to be read-write, we have to check that the agent effectively allows
// writing the attribute. It happens that the attribute is defiend in the MIB as read-write but the agent
// refuses to write it!!
//

			if (create_attribute == true)
			{
				Tango::Attr *new_attr;
				switch (data_type)
				{
				case Tango::DEV_LONG:
					if (spectrum == false)
						new_attr = new ScalarSnmpDataAttrib<Tango::DevLong>(att_name,data_type,att_w_type);
					else
						new_attr = new SpectrumSnmpDataAttrib<Tango::DevLong>(att_name,data_type,att_w_type);

					if (att_w_type == Tango::READ_WRITE)
					{
						if (check_write_authorized<Tango::DevLong>(att_name,first_coherency_failed) == -1)
						{
							delete new_attr;
							continue;
						}
					}

					if (spectrum == false)
						dattr_scalar_data.insert(make_pair(att_name,new ScalarSnmpData<Tango::DevLong>));
					else
						dattr_spectrum_data.insert(make_pair(att_name,new SpectrumSnmpData<Tango::DevLong>));

					break;

				case Tango::DEV_ULONG:
					if (spectrum == false)
						new_attr = new ScalarSnmpDataAttrib<Tango::DevULong>(att_name,data_type,att_w_type);
					else
						new_attr = new SpectrumSnmpDataAttrib<Tango::DevULong>(att_name,data_type,att_w_type);

					if (att_w_type == Tango::READ_WRITE)
					{
						if (check_write_authorized<Tango::DevULong>(att_name,first_coherency_failed) == -1)
						{
							delete new_attr;
							continue;
						}
					}

					if (spectrum == false)
						dattr_scalar_data.insert(make_pair(att_name,new ScalarSnmpData<Tango::DevULong>));
					else
						dattr_spectrum_data.insert(make_pair(att_name,new SpectrumSnmpData<Tango::DevULong>));

					break;

				case Tango::DEV_ULONG64:
					if (spectrum == false)
						new_attr = new ScalarSnmpDataAttrib<Tango::DevULong64>(att_name,data_type,att_w_type);
					else
						new_attr = new SpectrumSnmpDataAttrib<Tango::DevULong64>(att_name,data_type,att_w_type);

					if (att_w_type == Tango::READ_WRITE)
					{
						if (check_write_authorized<Tango::DevULong64>(att_name,first_coherency_failed) == -1)
						{
							delete new_attr;
							continue;
						}
					}

					if (spectrum == false)
						dattr_scalar_data.insert(make_pair(att_name,new ScalarSnmpData<Tango::DevULong64>));
					else
						dattr_spectrum_data.insert(make_pair(att_name,new SpectrumSnmpData<Tango::DevULong64>));
					break;

				case Tango::DEV_STRING:
					if (spectrum == false)
						new_attr = new ScalarSnmpDataAttrib<Tango::DevString>(att_name,data_type,att_w_type);
					else
						new_attr = new SpectrumSnmpDataAttrib<Tango::DevString>(att_name,data_type,att_w_type);

					if (att_w_type == Tango::READ_WRITE)
					{
						if (check_write_authorized<Tango::DevString>(att_name,first_coherency_failed) == -1)
						{
							delete new_attr;
							continue;
						}
					}

					if (spectrum == false)
						dattr_scalar_data.insert(make_pair(att_name,new ScalarSnmpData<Tango::DevString>));
					else
						dattr_spectrum_data.insert(make_pair(att_name,new SpectrumSnmpData<Tango::DevString>));
					break;

				default:
					new_attr = NULL;
					break;
				}

//
// Eventually, add label, unit and format attribute properties if defined by the user
//

				Tango::UserDefaultAttrProp	dynattr_prop;
				if (att_label.empty() == false)
					dynattr_prop.set_label(att_label.c_str());
				if (att_unit.empty() == false)
					dynattr_prop.set_unit(att_unit.c_str());
				if (att_format.empty() == false)
					dynattr_prop.set_format(att_format.c_str());

				new_attr->set_default_properties(dynattr_prop);

				add_attribute(new_attr);
			}
		}
	}

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command GetSnmpData related method
 *	Description: Get some data from the SNMP agent. The data to be retrieved
 *               is given to the command as input argument. The SNMP data are
 *               returned to the caller as string(s) or double(s). It is up to the
 *               client to convert them in the required data type.
 *
 *	@param argin The SNMP data name
 *	@returns The SNMP data as string(s) or double(s) according to  the
 *           SNMP data type
 */
//--------------------------------------------------------
Tango::DevVarDoubleStringArray *TangoSnmp::get_snmp_data(Tango::DevString argin)
{
	Tango::DevVarDoubleStringArray *argout;
	DEBUG_STREAM << "TangoSnmp::GetSnmpData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::get_snmp_data) ENABLED START -----*/

	oid 		anOID[MAX_OID_LEN];
	size_t 		anOID_len = MAX_OID_LEN;

	INFO_STREAM << "Entering get_snmp_data for data " << argin << endl;

//
// Is the snmp name provided in dot notation?
//

	bool doted_notation = false;
	string snmp_name(argin);
	int nb = count(snmp_name.begin(),snmp_name.end(),'.');
	if (nb > NB_DOT)
		doted_notation = true;

//
// Get info from SNMP for this name
//

	if (doted_notation == true)
	{
		int res = read_objid(argin,anOID,&anOID_len);
		if (res == 0)
		{
			stringstream ss;
			ss << "Snmp data " << argin << " cannot be converted into a SNMP object identifier (OID)";

			Tango::Except::throw_exception("TangoSnmp_CantConvertToOID",ss.str(),
											"TangoSnmp::get_snmp_data");
		}
	}
	else
	{
		int res_get = get_node(argin,anOID,&anOID_len);
		if (res_get == 0)
		{
			stringstream ss;
			ss << "Snmp data " << argin << " cannot be found in loaded MIB";

			Tango::Except::throw_exception("TangoSnmp_CantFindDataInMibs",ss.str(),
											"TangoSnmp::get_snmp_data");
		}
	}


//
// Check access type
//

	struct tree *tree_ptr = get_tree(anOID,anOID_len,get_tree_head());
	if (tree_ptr == NULL)
	{
		stringstream ss;
		ss << "Snmp data " << argin << " cannot be found in loaded MIB";

		Tango::Except::throw_exception("TangoSnmp_CantFindDataInMibs",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

	if (tree_ptr->type == 0 && tree_ptr->access == 0)
	{
		stringstream ss;
		ss << "Snmp data " << argin << " cannot be found";

		Tango::Except::throw_exception("TangoSnmp_CantFindData",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

	if (tree_ptr->access == MIB_ACCESS_NOACCESS ||
		tree_ptr->access == MIB_ACCESS_NOTIFY ||
		tree_ptr->access == MIB_ACCESS_CREATE ||
		tree_ptr->access == MIB_ACCESS_WRITEONLY)
	{
		stringstream ss;
		ss << "Snmp data " << argin << " is not accessible";

		Tango::Except::throw_exception("TangoSnmp_DataNotAccessible",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

//
// Check data type
//

	long convert_to = 0;

	switch(tree_ptr->type)
	{
	case TYPE_OBJID:
	case TYPE_OCTETSTR:
	case TYPE_NETADDR:
	case TYPE_IPADDR:
		convert_to = CONVERT_TO_STRING;
		break;

	case TYPE_INTEGER:
	case TYPE_INTEGER32:
	case TYPE_COUNTER:
	case TYPE_GAUGE:
	case TYPE_TIMETICKS:
	case TYPE_UINTEGER:
	case TYPE_UNSIGNED32:
	case TYPE_COUNTER64:
		convert_to = CONVERT_TO_DOUBLE;
		break;

	default:
		stringstream ss;
		ss << "Snmp data " << argin << " has one unsupported data type: " << tree_ptr->type;

		Tango::Except::throw_exception("TangoSnmp_NotSupportedDataType",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

//
// There are some cases where the data is defined in the MIB but is not accessible in SNMP as is
// For instance, this is the case if the given name is the name of one SNMP data which is a table.
// Try to read data from agent to check if we are in one of these cases
//

	struct snmp_pdu *pdu;
	struct snmp_pdu *response;
	struct variable_list *vars;
	int status;

	pdu = snmp_pdu_create(SNMP_MSG_GET);
	snmp_add_null_var(pdu,anOID,anOID_len);
	
    if (!simulationMode) {
		status = snmp_sess_synch_response(ss,pdu,&response);
    } else {
        //do what the agent response would do
        status = STAT_SUCCESS;
        response = snmp_clone_pdu(pdu);
        response->errstat = SNMP_ERR_NOERROR;
        int x = 100;
        snmp_set_var_typed_value(response->variables, response->variables->type, &x, sizeof(x));
    }
	string cmd_name("GetSnmpData");
	error_handling(status,cmd_name,response,"TangoSnmp::get_snmp_data","SNMP_GET",CMD);

	vars = response->variables;

	if (vars->type == SNMP_NOSUCHOBJECT ||
		vars->type == SNMP_NOSUCHINSTANCE ||
		vars->type == SNMP_ENDOFMIBVIEW)
	{
		try
		{
			string mod_name(argin);
			string::size_type pos = mod_name.rfind(".0");
			if (pos != string::npos && (pos == mod_name.size() - 2))
			{
				stringstream ss;
				ss << "Snmp data " << argin << " cannot be found";

				Tango::Except::throw_exception("TangoSnmp_CantFindData",ss.str(),"TangoSnmp::get_snmp_data");
			}
			mod_name = mod_name + ".0";

//
// Try to read data as a scalar (adding .0 at the end of the name)
//

			argout = get_snmp_data(const_cast<Tango::DevString>(mod_name.c_str()));
		}
		catch (Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			string reas(e.errors[0].reason.in());

			if (reas == "TangoSnmp_CantFindDataInMibs")
			{

//
// If the data is not found in MIB with the added .0 (as scalar), try to get it as an array (using GETBULK call)
//

				struct snmp_pdu *pdu;
				struct snmp_pdu *response;
				struct variable_list *vars;

				string full_name(argin);
				string::size_type pos = full_name.rfind(':');
				string endname = full_name.substr(pos + 1);

				pdu = snmp_pdu_create(SNMP_MSG_GETBULK);
				pdu->non_repeaters = 0;
				pdu->max_repetitions = 50;

				snmp_add_null_var(pdu,anOID,anOID_len);

				status = snmp_sess_synch_response(ss,pdu,&response);
				error_handling(status,cmd_name,response,"TangoSnmp::read_snmp_data_bulk","SNMP_GETBULK",CMD);

				argout = new Tango::DevVarDoubleStringArray();
				for (vars = response->variables;vars;vars = vars->next_variable)
				{

//
// Limit data to those we really want
//

					struct tree *tree_ptr = get_tree(vars->name,vars->name_length,get_tree_head());
					if (strcmp(tree_ptr->label,endname.c_str()) == 0)
					{
						print_variable(vars->name,vars->name_length,vars);
						cmd_convert_data(convert_to,argout,vars);
					}
					else
						break;
				}

				snmp_free_pdu(response);
			}
			else
				throw;
		}
	}
	else
	{

//
// The call succeeds, convert SNMP data to string or double
//

			print_variable(vars->name,vars->name_length,vars);

			argout = new Tango::DevVarDoubleStringArray();
			cmd_convert_data(convert_to,argout,vars);
	}

	snmp_free_pdu(response);

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::get_snmp_data
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSnmpData related method
 *	Description: Write a new value into a SNMP data. The snmp data name is given
 *               as the first string. Value to be written is passed to the command
 *               as the second string or as the first double.
 *
 *	@param argin s[0] = Snmp data name, s[1] = value to be written (for string data type)
 *               d[0] = value to be written (for number data type)
 */
//--------------------------------------------------------
void TangoSnmp::set_snmp_data(const Tango::DevVarDoubleStringArray *argin)
{
	DEBUG_STREAM << "TangoSnmp::SetSnmpData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::set_snmp_data) ENABLED START -----*/

//
// Check input args
//

	size_t s_num = argin->svalue.length();
	size_t d_num = argin->dvalue.length();

	if (s_num > 2 || d_num > 1 || s_num == 0)
	{
		Tango::Except::throw_exception("TangoSnmp_BadInputArgs",
										"Too many args in input data",
										"TangoSnmp::set_snmp_data");
	}

	INFO_STREAM << "Entering set_snmp_data " << argin->svalue[0] << endl;

	oid 		anOID[MAX_OID_LEN];
	size_t 		anOID_len = MAX_OID_LEN;

//
// Is the snmp name provided in dot notation?
//

	bool doted_notation = false;
	string snmp_name(argin->svalue[0]);
	int nb = count(snmp_name.begin(),snmp_name.end(),'.');
	if (nb > NB_DOT)
		doted_notation = true;

//
// Get info from SNMP for this name
//

	if (doted_notation == true)
	{
		int res = read_objid(argin->svalue[0],anOID,&anOID_len);
		if (res == 0)
		{
			stringstream ss;
			ss << "Snmp data " << argin->svalue[0] << " cannot be converted into a SNMP object identifier (OID)";

			Tango::Except::throw_exception("TangoSnmp_CantConvertToOID",ss.str(),
											"TangoSnmp::get_snmp_data");
		}
	}
	else
	{
		int res_get = get_node(argin->svalue[0],anOID,&anOID_len);
		if (res_get == 0)
		{
			stringstream ss;
			ss << "Snmp data " << argin->svalue[0] << " cannot be found in loaded MIB";

			Tango::Except::throw_exception("TangoSnmp_CantFindDataInMibs",ss.str(),
											"TangoSnmp::set_snmp_data");
		}
	}

//
// Check access type
//

	struct tree *tree_ptr = get_tree(anOID,anOID_len,get_tree_head());
	if (tree_ptr == NULL)
	{
		stringstream ss;
		ss << "Snmp data " << argin->svalue[0] << " cannot be found in loaded MIB";

		Tango::Except::throw_exception("TangoSnmp_CantFindDataInMibs",ss.str(),
										"TangoSnmp::set_snmp_data");
	}

	if (tree_ptr->type == 0 && tree_ptr->access == 0)
	{
		stringstream ss;
		ss << "Snmp data " << argin->svalue[0] << " cannot be found";

		Tango::Except::throw_exception("TangoSnmp_CantFindData",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

	if (tree_ptr->access == MIB_ACCESS_NOACCESS ||
		tree_ptr->access == MIB_ACCESS_NOTIFY ||
		tree_ptr->access == MIB_ACCESS_CREATE ||
		tree_ptr->access == MIB_ACCESS_WRITEONLY)
	{
		stringstream ss;
		ss << "Snmp data " << argin->svalue[0] << " is not accessible";

		Tango::Except::throw_exception("TangoSnmp_DataNotAccessible",ss.str(),
										"TangoSnmp::set_snmp_data");
	}

//
// Check data type
//

	long convert_to = 0;
	u_char snmp_type = 0;

	switch(tree_ptr->type)
	{
	case TYPE_OBJID:
	case TYPE_OCTETSTR:
	case TYPE_NETADDR:
	case TYPE_IPADDR:
		convert_to = CONVERT_TO_STRING;
		snmp_type = ASN_OCTET_STR;
		if (s_num != 2)
		{
			Tango::Except::throw_exception("TangoSnmp_BadInputArgs",
											"The SNMP data is a string but no string input arg given",
											"TangoSnmmp::set_snmp_data");
		}
		break;

	case TYPE_INTEGER:
	case TYPE_INTEGER32:
	case TYPE_COUNTER:
	case TYPE_GAUGE:
	case TYPE_TIMETICKS:
	case TYPE_UINTEGER:
	case TYPE_UNSIGNED32:
		convert_to = CONVERT_TO_DOUBLE;
		snmp_type = ASN_INTEGER;
		if (d_num != 1)
		{
			Tango::Except::throw_exception("TangoSnmp_BadInputArgs",
											"The SNMP data is a number but no number input arg given",
											"TangoSnmmp::set_snmp_data");
		}
		break;

	case TYPE_COUNTER64:
		convert_to = CONVERT_TO_DOUBLE;
		snmp_type = ASN_INTEGER64;
		if (d_num != 1)
		{
			Tango::Except::throw_exception("TangoSnmp_BadInputArgs",
											"The SNMP data is a number but no number input arg given",
											"TangoSnmmp::set_snmp_data");
		}
		break;

	default:
		stringstream ss;
		ss << "Snmp data " << argin->svalue[0] << " has one unsupported data type: " << tree_ptr->type;

		Tango::Except::throw_exception("TangoSnmp_NotSupportedDataType",ss.str(),
										"TangoSnmp::get_snmp_data");
	}

//
// Prepare SNMP call
//

	struct snmp_pdu* response = NULL;
	struct snmp_pdu* pdu = snmp_pdu_create(SNMP_MSG_SET);

	size_t len;
	if (convert_to == CONVERT_TO_STRING)
	{
		len = ::strlen(argin->svalue[1]);
		snmp_pdu_add_variable(pdu,anOID,anOID_len,snmp_type,(u_char*)argin->svalue[1].in(),len);
	}
	else
	{
		if (snmp_type == ASN_INTEGER)
		{
			Tango::DevLong data = (Tango::DevLong)argin->dvalue[0];
			len = sizeof(data);

			snmp_pdu_add_variable(pdu,anOID,anOID_len,snmp_type,(u_char*)&data,len);
		}
		else
		{
			Tango::DevLong64 data = (Tango::DevLong64)argin->dvalue[0];
			len = sizeof(data);

			snmp_pdu_add_variable(pdu,anOID,anOID_len,snmp_type,(u_char*)&data,len);
		}
	}

//
// Send the Request out.
//

	int status = snmp_sess_synch_response(ss,pdu,&response);
	string cmd_name("SetSnmpData");
	try
	{
		error_handling(status,cmd_name,response,"TangoSnmp::set_snmp_data","SNMP_SET",CMD);
	}
	catch (Tango::DevFailed &e)
	{
		response = NULL;

		string desc = e.errors[0].desc.in();
		if (desc.find("notWritable") != string::npos)
		{
			string mod_snmp_name(argin->svalue[0]);
			string::size_type pos = mod_snmp_name.rfind(".0");
			if (pos != string::npos && (pos == mod_snmp_name.size() - 2))
			{
				stringstream ss;
				ss << "Snmp data " << argin->svalue[0] << " cannot be found";

				Tango::Except::throw_exception("TangoSnmp_CantFindData",ss.str(),"TangoSnmp::set_snmp_data");
			}
			mod_snmp_name = mod_snmp_name + ".0";

			Tango::DevVarDoubleStringArray new_argin;
			new_argin.svalue.length(s_num);
			new_argin.svalue[0] = CORBA::string_dup(mod_snmp_name.c_str());
			if (s_num == 2)
				new_argin.svalue[1] = CORBA::string_dup(argin->svalue[1]);

			new_argin.dvalue = argin->dvalue;

			set_snmp_data(&new_argin);
		}
		else
			throw;
	}

	if (response)
		snmp_free_pdu(response);

	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::set_snmp_data
}
//--------------------------------------------------------
/**
 *	Command Simulate related method
 *	Description: (Experiment) Turn Simuation mode on/off
 *
 *	@param argin Enable simulation?
 */
//--------------------------------------------------------
void TangoSnmp::simulate(Tango::DevBoolean argin, Tango::Command &command)
{
	DEBUG_STREAM << "TangoSnmp::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(TangoSnmp::simulate) ENABLED START -----*/
	
	//	For now, this simply controls a global simulation flag.
    //	It could be expanded to allow per-attribute simulation etc.
    simulationMode = argin;
    // reconfigure connection to suit current simulation status
    init_device();
    
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::simulate
}
//--------------------------------------------------------
/**
 *	Method      : TangoSnmp::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void TangoSnmp::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_Simulate_dynamic_command("MySimulateCommand", true);
	
	/*----- PROTECTED REGION ID(TangoSnmp::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	add_Simulate_dynamic_command("GlobalSimulationEnable", true);
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmp::add_dynamic_commands
}

/*----- PROTECTED REGION ID(TangoSnmp::namespace_ending) ENABLED START -----*/

//	Additional Methods

//---------------------------------------------------------------------------------------------------------------------
//
// method :
//		TangoSnmp::cmd_convert_data()
//
// description :
//		Convert data returned by SNMP to the type used by the tango command GetSnmpData
//
// argument :
//		in :
//			- convert_to: To which data type it has to be converted (string or double)
//         	- argout: Pointer to the data returned by Tango
//			- vars: Data returned by SNMP
//
//--------------------------------------------------------------------------------------------------------------------

void TangoSnmp::cmd_convert_data(long convert_to,Tango::DevVarDoubleStringArray *argout,struct variable_list *vars)
{
	if (convert_to == CONVERT_TO_STRING)
	{
		argout->dvalue.length(0);
		argout->svalue.length(argout->svalue.length() + 1);

		if (vars->type == ASN_OBJECT_ID)
		{

//
// The SNMP data is one object ID, convert it to string
//

			stringstream ss;

			oid *tmp_ptr = vars->val.objid;
			int nb = vars->val_len / sizeof(oid);
			for (int loop = 0;loop < nb;loop++)
			{
				ss << *tmp_ptr;
				if (loop != (nb - 1))
					ss << ".";
				tmp_ptr++;
			}
			argout->svalue[argout->svalue.length() - 1] = CORBA::string_dup(ss.str().c_str());
		}
		else
		{
			char *ptr = CORBA::string_alloc(vars->val_len + 1);
			memcpy(ptr,(void *)(vars->val.string),vars->val_len);
			ptr[vars->val_len] = '\0';
			argout->svalue[argout->svalue.length() - 1] = ptr;
		}
	}
	else
	{
		argout->svalue.length(0);
		argout->dvalue.length(argout->dvalue.length() + 1);

		switch(vars->type)
		{
		case ASN_INTEGER:
		case ASN_TIMETICKS:
		case ASN_COUNTER:
		case ASN_UNSIGNED:
		case ASN_COUNTER64:
			argout->dvalue[argout->dvalue.length() - 1] = (double)*vars->val.integer;
			break;

		case ASN_OPAQUE_FLOAT:
			argout->dvalue[argout->dvalue.length() - 1] = (double)*vars->val.floatVal;
			break;

		case ASN_OPAQUE_DOUBLE:
			argout->dvalue[argout->dvalue.length() - 1] = *vars->val.doubleVal;
			break;

		default:
			stringstream ss;
			ss << "Snmp call returned one unsupported data type: " << vars->type;

			Tango::Except::throw_exception("TangoSnmp_NotSupportedDataType",ss.str(),
							"TangoSnmp::cmd_convert_data");
			break;
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------
//
// method :
//		TangoSnmp::check_coherency()
//
// description :
//		Method to check the coherency between the attribute as it is defined by the user device configuration
//		in Tango db and the information got from MIB or real SNMP access
//
// argument :
//		in :
//			- snmp_name: The SNMP data name
//         	- att_type: The attribute Tango data type (as a string)
//			- att_rw: The attribute Tango RW type
//			- att_name: The attribute name
//		out :
//			- required_type: The Tango data type required by the SNMP data type (For error message)
//
// return :
//		This method returns:
//			0 is everything works well
//			-1 if the net-snmp calls fails
//			-2 if the attribute RW access is incoherent with SNMP
//			-3 if the attribute data type is incoherent with SNMP
//			-4 if the data is defined in the MIB but the data type returned by SNMP makes it unaccessible as is
//			-5 if the data (name provided in dot notation) cant be found
//
//--------------------------------------------------------------------------------------------------------------------

int TangoSnmp::check_coherency(string &snmp_name,string &att_type,Tango::AttrWriteType &att_rw,string &att_name,string &required_type)
{
	TangoSnmp::Snmp_OID so;
	so.anOID_len = MAX_OID_LEN;
	so.bulk = false;
	so.snmp_name = snmp_name;
    so.sim_limits.push_back(0);
    so.sim_limits.push_back(100);
    so.sim_count = 100;

	INFO_STREAM << "Entering check_coherency for " << snmp_name << ", type = " << att_type <<  ", RW type = " << att_rw << endl;

//
// Is the snmp name provided in dot notation?
//

	bool doted_notation = false;
	int nb = count(snmp_name.begin(),snmp_name.end(),'.');
	if (nb > NB_DOT)
		doted_notation = true;

//
// Get info from SNMP for this name
//

	if (doted_notation == true)
	{
		int res = read_objid(snmp_name.c_str(),so.anOID,&so.anOID_len);
		if (res == 0)
			return -5;
	}
	else
	{
		int res_get = get_node(snmp_name.c_str(),so.anOID,&so.anOID_len);
		if (res_get == 0)
			return(-1);
	}

//
// Check access type
//

	struct tree *tree_ptr = get_tree(so.anOID,so.anOID_len,get_tree_head());
	if (tree_ptr == NULL)
	{
		return(-1);
	}

	if (tree_ptr->type == 0 && tree_ptr->access == 0)
	{
		return -5;
	}

	if (tree_ptr->access == MIB_ACCESS_READONLY && att_rw == Tango::READ_WRITE)
	{
		return(-2);
	}
	else if (tree_ptr->access == MIB_ACCESS_NOACCESS ||
			 tree_ptr->access == MIB_ACCESS_NOTIFY ||
			 tree_ptr->access == MIB_ACCESS_CREATE ||
			 tree_ptr->access == MIB_ACCESS_WRITEONLY)
	{
		return(-2);
	}

//
// Check data type
//

	switch(tree_ptr->type)
	{
	case TYPE_OBJID:
	case TYPE_OCTETSTR:
	case TYPE_NETADDR:
	case TYPE_IPADDR:
		if (att_type != "devstring")
		{
			required_type = "DevString";
			return (-3);
		}
		so.snmp_type = ASN_OCTET_STR;
		break;

	case TYPE_INTEGER:
	case TYPE_INTEGER32:
		if (att_type != "devlong")
		{
			required_type = "DevLong";
			return (-3);
		}
		so.snmp_type = ASN_INTEGER;
		break;

	case TYPE_COUNTER:
	case TYPE_GAUGE:
	case TYPE_TIMETICKS:
	case TYPE_UINTEGER:
	case TYPE_UNSIGNED32:
		if (att_type != "devulong")
		{
			required_type = "DevULong";
			return (-3);
		}
		so.snmp_type = ASN_INTEGER;
		break;

	case TYPE_COUNTER64:
		if (att_type != "devulong64")
		{
			required_type = "DevULong64";
			return (-3);
		}
		so.snmp_type = ASN_INTEGER64;
		break;

	default:
		return(-3);
	}

//
// There are some cases where the data is defined in the MIB but is not accessible in SNMP as is
// For instance, this is the case if the given name is the name of one SNMP data which is a table.
// Try to read data from agent to check if we are in one of these cases
//

	struct snmp_pdu *pdu;
	struct snmp_pdu *response;
	struct variable_list *vars;
	int status;
    
	pdu = snmp_pdu_create(SNMP_MSG_GET);
	snmp_add_null_var(pdu,so.anOID,so.anOID_len);

    // if ss is NULL, we have no connection to SNMP device, and therefore 
    // cannot check coherency. For the sake of having a representative 
    // device to look at, we will assume the configuration is correct.
	if (simulationMode or NULL == ss) 
    {
    	//do what the agent response would do
        status = STAT_SUCCESS;
        response = snmp_clone_pdu(pdu);
        response->errstat = SNMP_ERR_NOERROR;
        if(att_type == "devstring")
        {
            char* x = "sim";
            snmp_set_var_typed_value(response->variables, response->variables->type, &x, sizeof(x));
        }
        else
        {
            int x = 100;
            snmp_set_var_typed_value(response->variables, response->variables->type, &x, sizeof(x));
        }
    } 
    else 
    {
		status = snmp_sess_synch_response(ss,pdu,&response);
	}

	if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR)
	{
		for (vars = response->variables;vars;vars = vars->next_variable)
		{
			if (vars->type == SNMP_NOSUCHOBJECT ||
			    vars->type == SNMP_NOSUCHINSTANCE ||
				vars->type == SNMP_ENDOFMIBVIEW)
			{
				snmp_free_pdu(response);
				return (-4);
			}
		}
	}

	snmp_free_pdu(response);

//
// The call to read data is a success. memorize the OID
//

	DEBUG_STREAM << "Correct attribute data definition" << endl;
	att_OIDs.insert({att_name,so});
	return 0;
}

//---------------------------------------------------------------------------------------------------------------------
//
// method :
//		TangoSnmp::read_snmp_data_bulk_coherency()
//
// description :
//		Method to read SNMP data with a GETBULK network call. This is used for attribute which are arrays.
//		(And linked to SNMP table data).
//		This method is also used during the dynamic attributes creation phase where the coherency between the user
//		attribute definition and the SNMP data are validated.
//
// argument :
//		in :
//			- att_name: The attribute name
//			- snmp_name : The SNMP data name
//
// return :
//		This method returns:
//			0 is everything works well
//			-1 if the net-snmp calls fails
//
//--------------------------------------------------------------------------------------------------------------------

int TangoSnmp::read_snmp_data_bulk_coherency(string &att_name,string &snmp_name)
{
	INFO_STREAM << "Entering read_snmp_data_bulk for SNMP data " << snmp_name << endl;

//
// Try to retrieve OID from our map from attribute name
//

	map<string,Snmp_OID>::iterator ite = att_OIDs.find(att_name);
	TangoSnmp::Snmp_OID so;
	so.anOID_len = MAX_OID_LEN;
	so.bulk = true;
	so.snmp_name = snmp_name;
    so.sim_limits.push_back(0);
    so.sim_limits.push_back(100);
    so.sim_count = 100;
	if (ite == att_OIDs.end())
	{

//
// Get info from MIB for this name
//

		int res_get = get_node(snmp_name.c_str(),so.anOID,&so.anOID_len);
		if (res_get == 0)
		{
			return(-1);
		}
	}

//
// Ask SNMP for this data
//

	struct snmp_pdu *pdu;
	struct snmp_pdu *response;
	struct variable_list *vars;

	string full_name(snmp_name);
	string::size_type pos = full_name.rfind('.');
	string endname = full_name.substr(pos + 1);

	pdu = snmp_pdu_create(SNMP_MSG_GETBULK);
	pdu->non_repeaters = 0;
	pdu->max_repetitions = 10;

	if (ite == att_OIDs.end())
		snmp_add_null_var(pdu,so.anOID,so.anOID_len);
	else
		snmp_add_null_var(pdu,ite->second.anOID,ite->second.anOID_len);

	int status = snmp_sess_synch_response(ss,pdu,&response);

	if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR)
	{
		for (vars = response->variables;vars;vars = vars->next_variable)
		{

//
// Limit data to those we really want
//

			struct tree *tree_ptr = get_tree(vars->name,vars->name_length,get_tree_head());
			if (strcmp(tree_ptr->label,endname.c_str()) == 0)
				print_variable(vars->name,vars->name_length,vars);
		}

	}
	else
	{
		if (status == STAT_SUCCESS)
			cerr << "Error in response packet: " << snmp_errstring(response->errstat) << endl;
		else
		{
			int liberr,syserr;
			char *errstr;

			snmp_sess_error(ss,&liberr,&syserr,&errstr);
			cerr << "Error in response packet: " << errstr << endl;
		}

		return -1;
	}

	snmp_free_pdu(response);

//
// Insert OID in our map if the method is used during the coherency checks
//

	if (ite == att_OIDs.end())
	{
		DEBUG_STREAM << "Going to insert array OID in our map for " << snmp_name << endl;
		att_OIDs.insert({att_name,so});
	}

	return 0;
}

//---------------------------------------------------------------------------------------------------------------------
//
// method :
//		TangoSnmp::error_handling()
//
// description :
//		Create an appropriate error message in case the SNMP call failed and throws one exception with this message.
//
// argument :
//		in :
//			- status: SNMP call status
//         	- obj_name: The object name (attribute or command name)
//			- response: Response data received from SNMP
//			- meth_name: Caller method name
//			- snmp_call: SNMP call name
//			- ty: The request type (cmd or attribute)
//
//--------------------------------------------------------------------------------------------------------------------

void TangoSnmp::error_handling(int status,string &obj_name,struct snmp_pdu *response,const char *meth_name,
							   const char *snmp_call,enum Req_Type ty)
{
	if (status != STAT_SUCCESS)
	{
		stringstream sstr;
		sstr << "Error returned by SNMP during " << snmp_call << " for ";
		if (ty == CMD)
			sstr << "command ";
		else
			sstr << "attribute ";
		sstr << obj_name;

		if (status == STAT_TIMEOUT)
			sstr << "\nTimeout: No Response from " << agentIpAddr;
		else
		{
			int liberr,syserr;
			char *errstr;

			snmp_sess_error(ss,&liberr,&syserr,&errstr);
			sstr << "\n" << errstr;
		}

		Tango::Except::throw_exception("TangoSnmp_SnmpError",sstr.str(),meth_name);
	}
	else if (response != NULL && response->errstat != SNMP_ERR_NOERROR)
	{
		stringstream sstr;
		sstr << "Error returned by SNMP during " << snmp_call << " for ";
		if (ty == CMD)
			sstr << "command ";
		else
			sstr << "attribute ";
		sstr << obj_name;

		sstr << "\nSNMP error: ";
		sstr << snmp_errstring(response->errstat);

		snmp_free_pdu(response);
		Tango::Except::throw_exception("TangoSnmp_SnmpError",sstr.str(),meth_name);
	}
}

bool TangoSnmp::is_ScalarSnmpData_allowed(TANGO_UNUSED(Tango::AttReqType ty))
{
	if (get_state() != Tango::FAULT)
		return true;
	else
		return false;
}

bool TangoSnmp::is_SpectrumSnmpData_allowed(TANGO_UNUSED(Tango::AttReqType ty))
{
	if (get_state() != Tango::FAULT)
		return true;
	else
		return false;
}

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::namespace_ending
} //	namespace
