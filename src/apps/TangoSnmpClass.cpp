/*----- PROTECTED REGION ID(TangoSnmpClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id$";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL$";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        TangoSnmpClass.cpp
//
// description : C++ source for the TangoSnmpClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the TangoSnmp once per process.
//
// project :     Tango<-->Snmp link
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author$
//
// $Revision$
// $Date$
//
// $HeadURL$
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <TangoSnmpClass.h>

/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass.cpp

//-------------------------------------------------------------------
/**
 *	Create TangoSnmpClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_TangoSnmp_class(const char *name) {
		return TangoSnmp_ns::TangoSnmpClass::init(name);
	}
}

namespace TangoSnmp_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
TangoSnmpClass *TangoSnmpClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::TangoSnmpClass(string &s)
 * description : 	constructor for the TangoSnmpClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
TangoSnmpClass::TangoSnmpClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering TangoSnmpClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(TangoSnmpClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::constructor

	cout2 << "Leaving TangoSnmpClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::~TangoSnmpClass()
 * description : 	destructor for the TangoSnmpClass
 */
//--------------------------------------------------------
TangoSnmpClass::~TangoSnmpClass()
{
	/*----- PROTECTED REGION ID(TangoSnmpClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
TangoSnmpClass *TangoSnmpClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new TangoSnmpClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
TangoSnmpClass *TangoSnmpClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		GetSnmpDataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetSnmpDataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "GetSnmpDataClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<TangoSnmp *>(device))->get_snmp_data(argin));
}

//--------------------------------------------------------
/**
 * method : 		SetSnmpDataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetSnmpDataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SetSnmpDataClass::execute(): arrived" << endl;
	const Tango::DevVarDoubleStringArray *argin;
	extract(in_any, argin);
	((static_cast<TangoSnmp *>(device))->set_snmp_data(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SimulateClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SimulateClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SimulateClass::execute(): arrived" << endl;
	Tango::DevBoolean argin;
	extract(in_any, argin);
	((static_cast<TangoSnmp *>(device))->simulate(argin, *this));
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum TangoSnmpClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum TangoSnmpClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum TangoSnmpClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void TangoSnmpClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "community";
	prop_desc = "The comunity string used to build the connection to the agent";
	prop_def  = "public";
	vect_data.clear();
	vect_data.push_back("public");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "timeout";
	prop_desc = "Timeout (uS) for the agent communication";
	prop_def  = "500000";
	vect_data.clear();
	vect_data.push_back("500000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MIBFile";
	prop_desc = "List of MIB file to be loaded by the Tango class";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "AgentIpAddr";
	prop_desc = "The host IP address where the SNMP agent is running";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DynamicAttributes";
	prop_desc = "List of dynamic attributes to be instanciated by this device.\nEach string in the array defined one attribute with the following syntax:\natt_name=SNMP data name, Tango data type, READ or READ_WRITE,[label],[unit],[format]\nThe last three are optionals but if you omit one, the comma separator has to be used for proper string parsing. \nIf the MIB file is available to the software, the SNMP data name can be expressed using MIB OID notation. \nIt is not necessary to add the last .0 for simple data. \nThe attribute format will be automatically deduced from the information retrieved from SNMP.\nIf the defnition of the Tango attribute is incoherent with the MIB OID definition, the device state switches to ALARM\nand the device status gives you which attribute(s) aer wrongly defined.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void TangoSnmpClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Tango<-->Snmp link");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("This class is  a bridge between Tango and SNMP. It allows the user to get/set");
	str_desc.push_back("snmp data to/from a snmp agent. It is built on top of the <a href=\"http://www.net-snmp.org\" target=\"_top\">net-snmp</a> library.");
	str_desc.push_back("You can get/set SNMP data using generic commands or you can configure");
	str_desc.push_back("this Tango class to create  dynamic attributes which are the Tango part of SNMP data.");
	str_desc.push_back("See the definition of the device properties to find out how this can be achieved.");
	str_desc.push_back("To communicate with the SNMP agent, this class uses SNMP v2c.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void TangoSnmpClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(TangoSnmpClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new TangoSnmp(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		TangoSnmp *dev = static_cast<TangoSnmp *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();
		dev->add_dynamic_commands();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(TangoSnmpClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void TangoSnmpClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(TangoSnmpClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::attribute_factory_before
	//	Attribute : MIBFileDirs
	MIBFileDirsAttrib	*mibfiledirs = new MIBFileDirsAttrib();
	Tango::UserDefaultAttrProp	mibfiledirs_prop;
	mibfiledirs_prop.set_description("This attribute is the list of directories where the sofwtare will look for MIB files.");
	mibfiledirs_prop.set_label("MIB files directories");
	//	unit	not set for MIBFileDirs
	//	standard_unit	not set for MIBFileDirs
	//	display_unit	not set for MIBFileDirs
	//	format	not set for MIBFileDirs
	//	max_value	not set for MIBFileDirs
	//	min_value	not set for MIBFileDirs
	//	max_alarm	not set for MIBFileDirs
	//	min_alarm	not set for MIBFileDirs
	//	max_warning	not set for MIBFileDirs
	//	min_warning	not set for MIBFileDirs
	//	delta_t	not set for MIBFileDirs
	//	delta_val	not set for MIBFileDirs
	
	mibfiledirs->set_default_properties(mibfiledirs_prop);
	//	Not Polled
	mibfiledirs->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(mibfiledirs);

	//	Attribute : LoadedMIBModules
	LoadedMIBModulesAttrib	*loadedmibmodules = new LoadedMIBModulesAttrib();
	Tango::UserDefaultAttrProp	loadedmibmodules_prop;
	loadedmibmodules_prop.set_description("This is the list of the MIB modules loaded in the Tango server");
	loadedmibmodules_prop.set_label("Loaded MIB modules");
	//	unit	not set for LoadedMIBModules
	//	standard_unit	not set for LoadedMIBModules
	//	display_unit	not set for LoadedMIBModules
	//	format	not set for LoadedMIBModules
	//	max_value	not set for LoadedMIBModules
	//	min_value	not set for LoadedMIBModules
	//	max_alarm	not set for LoadedMIBModules
	//	min_alarm	not set for LoadedMIBModules
	//	max_warning	not set for LoadedMIBModules
	//	min_warning	not set for LoadedMIBModules
	//	delta_t	not set for LoadedMIBModules
	//	delta_val	not set for LoadedMIBModules
	
	loadedmibmodules->set_default_properties(loadedmibmodules_prop);
	//	Not Polled
	loadedmibmodules->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(loadedmibmodules);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(TangoSnmpClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void TangoSnmpClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(TangoSnmpClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::pipe_factory_before
	/*----- PROTECTED REGION ID(TangoSnmpClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void TangoSnmpClass::command_factory()
{
	/*----- PROTECTED REGION ID(TangoSnmpClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::command_factory_before


	//	Command GetSnmpData
	GetSnmpDataClass	*pGetSnmpDataCmd =
		new GetSnmpDataClass("GetSnmpData",
			Tango::DEV_STRING, Tango::DEVVAR_DOUBLESTRINGARRAY,
			"The SNMP data name",
			"The SNMP data as string(s) or double(s) according to  the\nSNMP data type",
			Tango::OPERATOR);
	command_list.push_back(pGetSnmpDataCmd);

	//	Command SetSnmpData
	SetSnmpDataClass	*pSetSnmpDataCmd =
		new SetSnmpDataClass("SetSnmpData",
			Tango::DEVVAR_DOUBLESTRINGARRAY, Tango::DEV_VOID,
			"s[0] = Snmp data name, s[1] = value to be written (for string data type)\nd[0] = value to be written (for number data type)",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetSnmpDataCmd);

	/*----- PROTECTED REGION ID(TangoSnmpClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void TangoSnmpClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(TangoSnmpClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		TangoSnmpClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void TangoSnmpClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		TangoSnmp *dev = static_cast<TangoSnmp *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(TangoSnmpClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : TangoSnmpClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *TangoSnmpClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(TangoSnmpClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	TangoSnmpClass::Additional Methods
} //	namespace
