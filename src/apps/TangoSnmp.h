/*----- PROTECTED REGION ID(TangoSnmp.h) ENABLED START -----*/
//=============================================================================
//
// file :        TangoSnmp.h
//
// description : Include file for the TangoSnmp class
//
// project :     Tango<-->Snmp link
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author$
//
// $Revision$
// $Date$
//
// $HeadURL$
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#ifndef TangoSnmp_H
#define TangoSnmp_H

#include <tango.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>



/*----- PROTECTED REGION END -----*/	//	TangoSnmp.h

/**
 *  TangoSnmp class description:
 *    This class is  a bridge between Tango and SNMP. It allows the user to get/set
 *    snmp data to/from a snmp agent. It is built on top of the <a href="http://www.net-snmp.org" target="_top">net-snmp</a> library.
 *    You can get/set SNMP data using generic commands or you can configure
 *    this Tango class to create  dynamic attributes which are the Tango part of SNMP data.
 *    See the definition of the device properties to find out how this can be achieved.
 *    To communicate with the SNMP agent, this class uses SNMP v2c.
 */

namespace TangoSnmp_ns
{
/*----- PROTECTED REGION ID(TangoSnmp::Additional Class Declarations) ENABLED START -----*/

//	Additional Class Declaration

#define		CONVERT_TO_STRING	1
#define		CONVERT_TO_DOUBLE	2

#define		NB_DOT				3


enum Req_Type
{
	CMD = 0,
	ATTR
};

class BaseSnmpData
{
public:
	BaseSnmpData() {};
	virtual ~BaseSnmpData() {};
};

template <typename T>
class ScalarSnmpData: public BaseSnmpData
{
public:
	ScalarSnmpData() {};
	~ScalarSnmpData() {};

	void set_attr_data(T d_in) {attr_data = d_in;}
	T *get_attr_data() {return &attr_data;}

protected:
	T	attr_data;
};

template <typename T>
class SpectrumSnmpData: public BaseSnmpData
{
public:
	SpectrumSnmpData() {};
	~SpectrumSnmpData() {};

//	void set_attr_data(T d_in) {attr_data = d_in;}
	T *get_attr_data_ptr() {return attr_data.data();}
	vector<T> &get_attr_data_ref() {return attr_data;}

protected:
	vector<T>	attr_data;
};

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::Additional Class Declarations

class TangoSnmp : public TANGO_BASE_CLASS
{

/*----- PROTECTED REGION ID(TangoSnmp::Data Members) ENABLED START -----*/

protected:

    bool simulationMode = false;
	void *ss;
	struct snmp_session session;

	typedef struct
	{
		oid 		anOID[MAX_OID_LEN];
		size_t 		anOID_len;
		bool 		bulk;
		string 		snmp_name;
		u_char		snmp_type;
        vector<int> sim_limits;
        int         sim_count;
	}Snmp_OID;

	map<string,Snmp_OID>			att_OIDs;

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::Data Members

//	Device property data members
public:
	//	community:	The comunity string used to build the connection to the agent
	string	community;
	//	timeout:	Timeout (uS) for the agent communication
	Tango::DevULong	timeout;
	//	MIBFile:	List of MIB file to be loaded by the Tango class
	vector<string>	mIBFile;
	//	AgentIpAddr:	The host IP address where the SNMP agent is running
	string	agentIpAddr;
	//	DynamicAttributes:	List of dynamic attributes to be instanciated by this device.
	//  Each string in the array defined one attribute with the following syntax:
	//  att_name=SNMP data name, Tango data type, READ or READ_WRITE,[label],[unit],[format]
	//  The last three are optionals but if you omit one, the comma separator has to be used for proper string parsing. 
	//  If the MIB file is available to the software, the SNMP data name can be expressed using MIB OID notation. 
	//  It is not necessary to add the last .0 for simple data. 
	//  The attribute format will be automatically deduced from the information retrieved from SNMP.
	//  If the defnition of the Tango attribute is incoherent with the MIB OID definition, the device state switches to ALARM
	//  and the device status gives you which attribute(s) aer wrongly defined.
	vector<string>	dynamicAttributes;
    
	bool	mandatoryNotDefined;

//	Attribute data members
public:
	Tango::DevString	*attr_MIBFileDirs_read;
	Tango::DevString	*attr_LoadedMIBModules_read;

//	Constructors and destructors
public:
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	TangoSnmp(Tango::DeviceClass *cl,string &s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	TangoSnmp(Tango::DeviceClass *cl,const char *s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device name
	 *	@param d	Device description.
	 */
	TangoSnmp(Tango::DeviceClass *cl,const char *s,const char *d);
	/**
	 * The device object destructor.
	 */
	~TangoSnmp() {delete_device();};


//	Miscellaneous methods
public:
	/*
	 *	will be called at device destruction or at init command.
	 */
	void delete_device();
	/*
	 *	Initialize the device
	 */
	virtual void init_device();
	/*
	 *	Read the device properties from database
	 */
	void get_device_property();
	/*
	 *	Always executed method before execution command method.
	 */
	virtual void always_executed_hook();

	/*
	 *	Check if mandatory property has been set
	 */
	 void check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop);

//	Attribute methods
public:
	//--------------------------------------------------------
	/*
	 *	Method      : TangoSnmp::read_attr_hardware()
	 *	Description : Hardware acquisition for attributes.
	 */
	//--------------------------------------------------------
	virtual void read_attr_hardware(vector<long> &attr_list);

/**
 *	Attribute MIBFileDirs related methods
 *	Description: This attribute is the list of directories where the sofwtare will look for MIB files.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 128
 */
	virtual void read_MIBFileDirs(Tango::Attribute &attr);
	virtual bool is_MIBFileDirs_allowed(Tango::AttReqType type);
/**
 *	Attribute LoadedMIBModules related methods
 *	Description: This is the list of the MIB modules loaded in the Tango server
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1024
 */
	virtual void read_LoadedMIBModules(Tango::Attribute &attr);
	virtual bool is_LoadedMIBModules_allowed(Tango::AttReqType type);


	//--------------------------------------------------------
	/**
	 *	Method      : TangoSnmp::add_dynamic_attributes()
	 *	Description : Add dynamic attributes if any.
	 */
	//--------------------------------------------------------
	void add_dynamic_attributes();




//	Command related methods
public:
	/**
	 *	Command GetSnmpData related method
	 *	Description: Get some data from the SNMP agent. The data to be retrieved
	 *               is given to the command as input argument. The SNMP data are
	 *               returned to the caller as string(s) or double(s). It is up to the
	 *               client to convert them in the required data type.
	 *
	 *	@param argin The SNMP data name
	 *	@returns The SNMP data as string(s) or double(s) according to  the
	 *           SNMP data type
	 */
	virtual Tango::DevVarDoubleStringArray *get_snmp_data(Tango::DevString argin);
	virtual bool is_GetSnmpData_allowed(const CORBA::Any &any);
	/**
	 *	Command SetSnmpData related method
	 *	Description: Write a new value into a SNMP data. The snmp data name is given
	 *               as the first string. Value to be written is passed to the command
	 *               as the second string or as the first double.
	 *
	 *	@param argin s[0] = Snmp data name, s[1] = value to be written (for string data type)
	 *               d[0] = value to be written (for number data type)
	 */
	virtual void set_snmp_data(const Tango::DevVarDoubleStringArray *argin);
	virtual bool is_SetSnmpData_allowed(const CORBA::Any &any);

//	Dynamic commands methods
public:
	/**
	 *	Command Simulate related method
	 *	Description: (Experiment) Turn Simuation mode on/off
	 *
	 *	@param argin Enable simulation?
	 */
	virtual void simulate(Tango::DevBoolean argin,Tango::Command &command);
	virtual bool is_Simulate_allowed(const CORBA::Any &any);
	void add_Simulate_dynamic_command(string cmdname, bool device);
	void remove_Simulate_dynamic_command(string cmdname);

	//--------------------------------------------------------
	/**
	 *	Method      : TangoSnmp::add_dynamic_commands()
	 *	Description : Add dynamic commands if any.
	 */
	//--------------------------------------------------------
	void add_dynamic_commands();

/*----- PROTECTED REGION ID(TangoSnmp::Additional Method prototypes) ENABLED START -----*/

//	Additional Method prototypes
protected:
	int check_coherency(string &,string &,Tango::AttrWriteType &,string &,string &);
	template <typename T> int check_write_authorized(string &,bool &);
	int read_snmp_data_bulk_coherency(string &,string &);
	void cmd_convert_data(long,Tango::DevVarDoubleStringArray *,struct variable_list *);
	template <typename T> void read_snmp_data(string &,ScalarSnmpData<T> *);
	template <typename T> void read_snmp_data_bulk(string &,SpectrumSnmpData<T> *);
	void error_handling(int,string &,struct snmp_pdu *,const char *,const char *,enum Req_Type);
	template <typename T> void write_snmp_data(string &,T data);

	map<string,BaseSnmpData *>		dattr_scalar_data;
	map<string,BaseSnmpData *> 		dattr_spectrum_data;

public:
	template <typename T> void read_ScalarSnmpDataAttr(Tango::Attribute &);
	template <typename T> void write_ScalarSnmpDataAttr(Tango::WAttribute &);
	bool is_ScalarSnmpData_allowed(Tango::AttReqType);

	template <typename T> void read_SpectrumSnmpDataAttr(Tango::Attribute &);
	template <typename T> void write_SpectrumSnmpDataAttr(Tango::WAttribute &);
	bool is_SpectrumSnmpData_allowed(Tango::AttReqType);

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::Additional Method prototypes
};

/*----- PROTECTED REGION ID(TangoSnmp::Additional Classes Definitions) ENABLED START -----*/

//	Additional Classes Definitions

template <typename T>
class ScalarSnmpDataAttrib: public Tango::Attr
{
public:
	ScalarSnmpDataAttrib(const string &att_name,long d_type,Tango::AttrWriteType att_rw):
	Attr(att_name.c_str(), d_type, att_rw) {};
	~ScalarSnmpDataAttrib() {};

	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
		{(static_cast<TangoSnmp *>(dev))->read_ScalarSnmpDataAttr<T>(att);}
	virtual void write(Tango::DeviceImpl *dev,Tango::WAttribute &att)
		{(static_cast<TangoSnmp *>(dev))->write_ScalarSnmpDataAttr<T>(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
		{return (static_cast<TangoSnmp *>(dev))->is_ScalarSnmpData_allowed(ty);}
};


template <typename T>
class SpectrumSnmpDataAttrib: public Tango::SpectrumAttr
{
public:
	SpectrumSnmpDataAttrib(const string &att_name,long d_type,Tango::AttrWriteType att_rw):
	SpectrumAttr(att_name.c_str(), d_type, att_rw,1024) {};
	~SpectrumSnmpDataAttrib() {};

	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
		{(static_cast<TangoSnmp *>(dev))->read_SpectrumSnmpDataAttr<T>(att);}
	virtual void write(Tango::DeviceImpl *dev,Tango::WAttribute &att)
		{(static_cast<TangoSnmp *>(dev))->write_SpectrumSnmpDataAttr<T>(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
		{return (static_cast<TangoSnmp *>(dev))->is_SpectrumSnmpData_allowed(ty);}
};

/*----- PROTECTED REGION END -----*/	//	TangoSnmp::Additional Classes Definitions

}	//	End of namespace

#endif   //	TangoSnmp_H
